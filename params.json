{"name":"PySMT","tagline":"pySMT: A solver-agnostic library for SMT formulae manipulation and solving","body":"============================================================\r\n pySMT: A library for SMT formulae manipulation and solving\r\n============================================================\r\n\r\npySMT makes working with Satisfiability Modulo Theory simple.\r\n\r\nAmong others, you can:\r\n\r\n* Define formulae in a solver independent way in a simple and\r\n  inutitive way,\r\n* Write ad-hoc simplifiers and operators,\r\n* Dump your problems in the SMT-Lib format,\r\n* Solve them using one of the native solvers, or by wrapping any\r\n  SMT-Lib complaint solver.\r\n\r\n\r\nSupported Theories and Solvers\r\n==============================\r\npySMT provides methods to define a formula in Linear Real Arithmetic (LRA), Real Difference Logic (RDL), their combination (LIRA),\r\nEqualities and Uninterpreted Functions (EUF) and Bit-Vectors (BV). The following solvers are supported through native APIs:\r\n\r\n* MathSAT (<http://mathsat.fbk.eu/>) >= 5\r\n* Z3 (http://z3.codeplex.com/releases) >= 4\r\n* CVC4 (http://cvc4.cs.nyu.edu/web/)\r\n* Yices 2 (http://yices.csl.sri.com/)\r\n* repycudd (https://github.com/pysmt/repycudd)\r\n* PicoSAT (http://fmv.jku.at/picosat/)\r\n\r\nAdditionally, you can use any SMT-LIB 2 compliant solver.\r\n\r\nPySMT assumes that the python bindings for the SMT Solver are installed and accessible from your PYTHONPATH. For Yices 2 we rely on pyices (https://github.com/cheshire/pyices).\r\n\r\npySMT works on both Python 2 and Python 3. Some solvers support both versions (e.g., MathSAT) but in general, many solvers still support only Python 2.\r\n\r\n\r\nThe following table summarizes the features supported via pySMT for\r\neach of the available solvers. (We indicate with square brackets the\r\nfeatures that are supported by the solver itself by not by the current\r\nwrapper used within pySMT).\r\n\r\n  =================   ==========   ==================   ==============   ==================   ==========\r\n  Solver              pySMT name   Supported Logics     Satisfiability   Model Construction   UNSAT-Core\r\n  =================   ==========   ==================   ==============   ==================   ==========\r\n  MathSAT             msat         QF_UFLIRA, QF_BV     Yes              Yes                  Yes\r\n  Z3                  z3           UFLIRA, [QF_BV]      Yes              Yes                  Yes\r\n  CVC4                cvc4         QF_UFLIRA, [QF_BV]   Yes              Yes                  No\r\n  Yices               yices        QF_UFLIRA, [QF_BV]   Yes              Yes                  No\r\n  SMT-Lib Interface   <custom>     UFLIRA, [QF_BV]      Yes              Yes                  No [Yes]\r\n  PicoSAT             picosat      QF_BOOL              Yes              Yes                  No [Yes]\r\n  BDD (CUDD)          bdd          BOOL                 Yes              Yes                  No\r\n  =================   ==========   ==================   ==============   ==================   ==========\r\n\r\nThe following table summarizes the features supported via pySMT for each of the available quantifier eliminators\r\n\r\n  =====================   ==========   ================\r\n  Quantifier Eliminator   pySMT name   Supported Logics\r\n  =====================   ==========   ================\r\n  MathSAT FM              msat-fm      LRA\r\n  MathSAT LW              msat-lw      LRA\r\n  Z3                      z3           LRA, LIA\r\n  BDD (CUDD)              bdd          BOOL\r\n  =====================   ==========   ================\r\n\r\nThe following table summarizes the features supported via pySMT for each of the available Craig interpolators\r\n\r\n  ============   ==========   =========================\r\n  Interpolator   pySMT name   Supported Logics\r\n  ============   ==========   =========================\r\n  MathSAT        msat         QF_UFLIA, QF_UFLRA, QF_BV\r\n  Z3             z3           QF_UFLIA, QF_UFLRA\r\n  ============   ==========   =========================\r\n\r\n\r\nGetting Started\r\n===============\r\nYou can install the latest stable release of pySMT from PyPI:\r\n\r\n  # pip install pysmt\r\nthis will additionally install the *pysmt-install* command, that can be used to install the solvers: e.g.,\r\n\r\n  $ pysmt-install --check\r\nwill show you which solvers have been found in your PYTHONPATH. For instructions on how to install each solver refer to the section on *solvers installation*.\r\n\r\nUsage\r\n=====\r\n\r\n.. code:: python\r\n\r\n  from pysmt.shortcuts import Symbol, And, Not, is_sat\r\n\r\n  varA = Symbol(\"A\") # Default type is Boolean\r\n  varB = Symbol(\"B\")\r\n  f = And([varA, Not(varB)])\r\n  g = f.substitute({varB:varA})\r\n\r\n  res = is_sat(f)\r\n  assert res # SAT\r\n  print(\"f := %s is SAT? %s\" % (f, res))\r\n\r\n  res = is_sat(g)\r\n  print(\"g := %s is SAT? %s\" % (g, res))\r\n  assert not res # UNSAT\r\n\r\n\r\nA more complex example is the following:\r\n\r\nLets consider the letters composing the words *HELLO* and *WORLD*,\r\nwith a possible integer value between 1 and 10 to each of them.\r\nIs there a value for each letter so that H+E+L+L+O = W+O+R+L+D = 25?\r\n\r\nThe following is the pySMT code for solving this problem:\r\n\r\n.. code:: python\r\n\r\n  from pysmt.shortcuts import Symbol, And, GE, LT, Plus, Equals, Int, get_model\r\n  from pysmt.typing import INT\r\n\r\n  hello = [Symbol(s, INT) for s in \"hello\"]\r\n  world = [Symbol(s, INT) for s in \"world\"]\r\n  letters = set(hello+world)\r\n  domains = And([And(GE(l, Int(1)),\r\n                     LT(l, Int(10))) for l in letters])\r\n\r\n  sum_hello = Plus(hello) # n-ary operators can take lists\r\n  sum_world = Plus(world) # as arguments\r\n  problem = And(Equals(sum_hello, sum_world),\r\n                Equals(sum_hello, Int(25)))\r\n  formula = And(domains, problem)\r\n\r\n  print(\"Serialization of the formula:\")\r\n  print(formula)\r\n\r\n  model = get_model(formula)\r\n  if model:\r\n    print(model)\r\n  else:\r\n    print(\"No solution found\")\r\n\r\n\r\nSolvers Installation\r\n====================\r\n\r\nPySMT does not depend directly on any solver. If you want to perform solving, you need to have at least one solver installed, and then call it via pySMT either through its native API, or passing through an SMT-LIB file.\r\n\r\nThe script *pysmt-install* can be used to simplify the installation of the solvers:\r\n\r\n $ pysmt-install --msat\r\nwill install MathSAT 5. This script does not install required dependencies for building the solver (e.g., make or gcc) and has been tested mainly on Linux Debian/Ubuntu systems. We suggest that you refer to the documentation of each solver to understand how to install it with its python bindings. Nevertheless, we try to keep *pysmt/cmd/install.py* as readable and documented as possible..\r\n\r\nFinally, for CVC4 and picosat, we have patches that need to be applied. The patches are available in the repository 'pysmt/solvers_patches' and should be applied against the following versions of the solvers:\r\n\r\n- CVC4: Git revision 68f22235a62f5276b206e9a6692a85001beb8d42\r\n- pycudd: 2.0.2\r\n- picosat 960\r\n\r\nFor instruction on how to use any SMT-LIB complaint solver with pySMT see examples/generic_smtlib.py\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}